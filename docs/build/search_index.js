var documenterSearchIndex = {"docs":
[{"location":"#EDKit.jl","page":"EDKit.jl","title":"EDKit.jl","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"Julia package for general many-body exact diagonalization calculation. The package provide a general Hamiltonian constructing routine for specific symmetry sectors. The functionalities can be extended with user-defined bases.","category":"page"},{"location":"#Installation","page":"EDKit.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"Run the following script in the Pkg REPL :","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"pkg> add EDKit","category":"page"},{"location":"#Basis-Object","page":"EDKit.jl","title":"Basis Object","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"In EDKit.jl, the fundamental objects are basis and operator. The AbstractBasis is the abstract type of basis. Currently there are 4 concrete basis:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"TensorBasis: Ordinary basis without any symmetry.\nProjectedBasis: Basis for subspace that is spanned only by product states.\nTranslationalBasis: Basis for translational symmetric Hamiltonian.\nTranslationalParityBasis : Basis with translational and reflection symmetry. The momensum should be 0 or π.","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"The basis object can be extended. To construct linear operation, we need to define 3 functions for a new basis type:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"size(b::AbstractBasis) : Size of matrix representations of the operators in this subspace.\nchange!(b::AbstractBasis, i::Integer) : Return the normalization of ith state and change the digits to ith states in this subspace.\nindex(b::AbstractBasis) : Return the coefficient and index of the digits.","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"Optionally, we can define eltype for a basis object (default is ComplexF64).","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"If the calculation is done on the entire Hilbert space, the basis object need not be explicitly constructed. The Operator will use TensorBasis by default. The construction of other basis with symmetry concern are discussed below.","category":"page"},{"location":"#Operator-Object","page":"EDKit.jl","title":"Operator Object","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"In EDKit.jl , a many-body operator is represented by the type Operator:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"struct Operator{Tv<:Number, Tb<:AbstractBasis}\n    M::Vector{SparseMatrixCSC{Tv, Int}}\n    I::Vector{Vector{Int}}\n    B::Tb\nend","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"In this definition, M is the list of matrix representations of local operators, I is the list of indices of sites it acts on.","category":"page"},{"location":"#Construction","page":"EDKit.jl","title":"Construction","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"To construct an Operator object, we need 3 inputs:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"M <: AbstractVector{<:AbstractMatrix}\nI <: AbstractVector{<:AbstractVector{<:Integer}}\nB <: AbstractBasis","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"where M is the list of matrices representing the local operators, I is the list of vectors representing the sites it acts on. B is a basis object. If use TensorBasis, we can directly using the constructing method","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"operator(mats::AbstractVector{<:AbstractMatrix}, inds::AbstractVector{<:AbstractVector}, L::Integer)","category":"page"},{"location":"#Convert-to-matrix","page":"EDKit.jl","title":"Convert to matrix","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"An Operator object is basically like a matrix, and it can be convert to dense matrix using the function","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"Array(opt::Operation)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"It can also write to a given matrix with correct dimension using function","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"addto!(M::AbstractMatrix, opt::Operator)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"Note that to get correct answer, M should de initialized as a zero matrix.","category":"page"},{"location":"#Multiply-to-vector-or-matrix","page":"EDKit.jl","title":"Multiply to vector or matrix","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"We can directly using","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"O::Operator * M::AbstractVecOrMat","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"to do the multiplycation. Or, use the function","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"mul!(target::AbstractVecOrMat, opt::Operator, v::AbstractVecOrMat)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"to modify target (similarly, target should be initialized as a zero vector/matrix).","category":"page"},{"location":"#Concrete-Implementations-of-Basis","page":"EDKit.jl","title":"Concrete Implementations of Basis","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"Here we introduce 3 concrete implementation of AbstractBasis.","category":"page"},{"location":"#TensorBasis","page":"EDKit.jl","title":"TensorBasis","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"The type TensorBasis has the fields:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"struct TensorBasis <: AbstractBasis\n    dgt::Vector{Int}\n    B::Int\nend","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"We can use the function","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"tensorbasis(L::Integer; base::Integer=2)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"to construct a basis, though in most cases it is not necessary.","category":"page"},{"location":"#ProjectedBasis","page":"EDKit.jl","title":"ProjectedBasis","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"The type ProjectedBasis has the fields:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"struct ProjectedBasis <: AbstractBasis\n    dgt::Vector{Int}\n    I::Vector{Int}\n    B::Int\nend","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"We can use the function","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"projectedbasis(f, L::Integer; base::Integer=2)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"In the definition, f is a function acting on digits that tells whether a given digits is valid in this basis. For eaxample, consider a S=1/2 chain with L=6 (conserve megnetic quantum number). If we consider the subspace spaned by those states with 3 up-spins, we can create the basis for the subspace by","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"projectedbasis(x -> sum(x)==3, 6; base=2)","category":"page"},{"location":"#TranslationalBasis","page":"EDKit.jl","title":"TranslationalBasis","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"The type TranslationalBasis has the fields:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"struct TranslationalBasis <: AbstractBasis\n    dgt::Vector{Int}\n    I::Vector{Int}\n    R::Vector{Float64}\n    C::ComplexF64\n    B::Int\nend","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"We can use the function","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"translationalbasis(k::Integer, L::Integer; base::Integer=2)\ntranslationalbasis(f, k::Integer, L::Integer; base::Integer=2)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"In the definition, k is the momentum sector we are interested, and f is a function acting on digits that tells whether a given digits is valid in this basis. Note that k is an integer, representing the momentum at 2πk/L. For example, consider a S=1/2 chain with L=6 (with translational symmetry and conserve magnetic quantum number). If we consider the subspace spaned by those states with 3 up-spins with zero momentum, we can create the basis for the subspace by","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"translationalbasis(x -> sum(x)==3, 0, 6; base=2)","category":"page"},{"location":"#Spin-tools","page":"EDKit.jl","title":"Spin tools","text":"","category":"section"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"We also provide a helper function to create spin-s operators (represented by matrices):","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"spin(spins...; D::Integer=2)","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"In the definition, spins are arbituary number of tuples such as (1.0, \"xzx\"). The supported characters are:","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"\"x\", \"y\", \"z\", \"1\", \"+\", \"-\"","category":"page"},{"location":"","page":"EDKit.jl","title":"EDKit.jl","text":"The other input D is the dimension of the matrix (D = 2s+1).","category":"page"}]
}
