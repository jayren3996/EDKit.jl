var documenterSearchIndex = {"docs":
[{"location":"basis/#Basis","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"In EDKit.jl, the fundamental objects are basis and operator. The AbstractBasis is the abstract type of basis. Currently there are 4 concrete basis:","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"TensorBasis: Ordinary basis without any symmetry.\nProjectedBasis: Basis for subspace that is spanned only by product states.\nTranslationalBasis: Basis for translational symmetric Hamiltonian.\nTranslationalParityBasis : Basis with translational as well as reflection symmetry. The momensum should be 0 or π.","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"The basis object can be extended. To construct linear operation, we need to define 3 functions for a new basis type:","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"size(b::AbstractBasis) : Size of matrix representations of the operators in this subspace.\nchange!(b::AbstractBasis, i::Integer) : Return the normalization of ith state and change the digits to ith states in this subspace.\nindex(b::AbstractBasis) : Return the coefficient and index of the digits.","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"Optionally, we can define eltype for a basis object (default is ComplexF64).","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"If the calculation is done on the entire Hilbert space, the basis object need not be explicitly constructed. The Operator will use TensorBasis by default. The construction of other basis with symmetry concern are discussed below.","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"In addition, if the entaglement entropy is needed, the user-defined basis should implement a function schmidt!(target, v, Ainds, b::AbstractBasis).","category":"page"},{"location":"basis/#Concrete-Implementations-of-Basis","page":"Basis","title":"Concrete Implementations of Basis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"Here we introduce 3 concrete implementation of AbstractBasis.","category":"page"},{"location":"basis/#TensorBasis","page":"Basis","title":"TensorBasis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"The type TensorBasis has the fields:","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"struct TensorBasis <: AbstractBasis\n    dgt::Vector{Int}\n    B::Int\nend","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"We can use the function","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"tensorbasis(L::Integer; base::Integer=2)","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"to construct a basis, though in most cases it is not necessary.","category":"page"},{"location":"basis/#ProjectedBasis","page":"Basis","title":"ProjectedBasis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"The type ProjectedBasis has the fields:","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"struct ProjectedBasis <: AbstractBasis\n    dgt::Vector{Int}\n    I::Vector{Int}\n    B::Int\nend","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"We can use the function","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"projectedbasis(f, L::Integer; base::Integer=2)","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"In the definition, f is a function acting on digits that tells whether a given digits is valid in this basis. For eaxample, consider a S=1/2 chain with L=6 (conserve megnetic quantum number). If we consider the subspace spaned by those states with 3 up-spins, we can create the basis for the subspace by","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"projectedbasis(x -> sum(x)==3, 6; base=2)","category":"page"},{"location":"basis/#TranslationalBasis","page":"Basis","title":"TranslationalBasis","text":"","category":"section"},{"location":"basis/","page":"Basis","title":"Basis","text":"The type TranslationalBasis has the fields:","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"struct TranslationalBasis <: AbstractBasis\n    dgt::Vector{Int}\n    I::Vector{Int}\n    R::Vector{Float64}\n    C::ComplexF64\n    B::Int\nend","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"We can use the function","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"translationalbasis(k::Integer, L::Integer; base::Integer=2)\ntranslationalbasis(f, k::Integer, L::Integer; base::Integer=2)","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"In the definition, k is the momentum sector we are interested, and f is a function acting on digits that tells whether a given digits is valid in this basis. Note that k is an integer, representing the momentum at 2πk/L. For example, consider a S=1/2 chain with L=6 (with translational symmetry and conserve magnetic quantum number). If we consider the subspace spaned by those states with 3 up-spins with zero momentum, we can create the basis for the subspace by","category":"page"},{"location":"basis/","page":"Basis","title":"Basis","text":"translationalbasis(x -> sum(x)==3, 0, 6; base=2)","category":"page"},{"location":"expl/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"expl/#Radom-XXZ-Model-with-Random","page":"Examples","title":"Radom XXZ Model with Random","text":"","category":"section"},{"location":"expl/","page":"Examples","title":"Examples","text":"Consider the Hamiltonian H = ∑ᵢ (σᵢˣσᵢ₊₁ˣ + σᵢʸσᵢ₊₁ʸ + hᵢσᵢᶻσᵢ₊₁ᶻ). We choose the system size to be L=10. The Hamiltonian need 3 generic information: ","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"Local operators represented by matrices;\nSite indices where each local operator acts on;\nBasis, if use the default tensor-product basis, only need to provide the system size.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"The following script generate the information we need to generate XXZ Hamiltonian:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"L = 10\nmats = [\n    fill(spin(\"XX\"), L);\n    fill(spin(\"YY\"), L);\n    [randn() * spin(\"ZZ\") for i=1:L]\n]\ninds = [\n    [[i, mod(i, L)+1] for i=1:L];\n    [[i, mod(i, L)+1] for i=1:L];\n    [[i, mod(i, L)+1] for i=1:L]\n]\nH = operator(mats, inds, L)","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"Then we can use the constructor operator to create Hamiltonian:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> H = operator(mats, inds, L)\nOperator of size (1024, 1024) with 10 terms.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"The constructor return an Operator object, which is a linear operator that can act on vector/ matrix. For example, we can act H on the ferromagnetic state:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> ψ = zeros(2^L); ψ[1] = 1; H * random_state\n1024-element Vector{Float64}:\n -1.5539463277491536\n  5.969061189628827\n  3.439873269795492\n  1.6217619009059376\n  0.6101231697221667\n  6.663735992405236\n  ⋮\n  5.517409105968883\n  0.9498121684380652\n -0.0004996659995972763\n  2.6020967735388734\n  4.99027405325114\n -1.4831032210847952","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"If we need a matrix representation of the Hamitonian, we can convert H to julia array by:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> Array(H)\n1024×1024 Matrix{Float64}:\n -1.55617  0.0       0.0       0.0     …   0.0      0.0       0.0\n  0.0      4.18381   2.0       0.0         0.0      0.0       0.0\n  0.0      2.0      -1.42438   0.0         0.0      0.0       0.0\n  0.0      0.0       0.0      -1.5901      0.0      0.0       0.0\n  0.0      0.0       2.0       0.0         0.0      0.0       0.0\n  0.0      0.0       0.0       2.0     …   0.0      0.0       0.0\n  ⋮                                    ⋱                     \n  0.0      0.0       0.0       0.0         0.0      0.0       0.0\n  0.0      0.0       0.0       0.0         2.0      0.0       0.0\n  0.0      0.0       0.0       0.0     …   0.0      0.0       0.0\n  0.0      0.0       0.0       0.0        -1.42438  2.0       0.0\n  0.0      0.0       0.0       0.0         2.0      4.18381   0.0\n  0.0      0.0       0.0       0.0         0.0      0.0      -1.55617","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"Or use the function sparse to create the sparse matrix (requires the module SparseArrays being imported):","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> sparse(H)\n1024×1024 SparseMatrixCSC{Float64, Int64} with 6144 stored entries:\n⠻⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⢹⡻⣮⡳⠄⢠⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠙⠎⢿⣷⡀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠲⣄⠈⠻⣦⣄⠙⠀⠀⠀⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠈⠳⣄⠙⡻⣮⡳⡄⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⠮⢻⣶⡄⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀\n⢤⡀⠀⠀⠀⠀⠠⣄⠀⠀⠀⠉⠛⣤⣀⠀⠀⠀⠙⠂⠀⠀⠀⠀⠈⠓\n⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠘⠿⣧⡲⣄⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⣄⠀⠀⠘⢮⡻⣮⣄⠙⢦⡀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⠳⠀⠀⠀⣄⠙⠻⣦⡀⠙⠦⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠈⢿⣷⡰⣄⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠈⠃⠐⢮⡻⣮⣇⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠻⣦","category":"page"},{"location":"expl/#Translational-invariant-AKLT-Model","page":"Examples","title":"Translational-invariant AKLT Model","text":"","category":"section"},{"location":"expl/","page":"Examples","title":"Examples","text":"Consider the AKLT model H = ∑ᵢ S⃗ᵢ⋅S⃗ᵢ₊₁ + 1/3 ∑ᵢ (S⃗ᵢ⋅S⃗ᵢ₊₁)², with system size chosen to be L=8. The Hamiltonian operator for this translational-invariant Hamiltonian can be constructed using the trans_inv_operator function:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"L = 8\nSS = spin((1, \"xx\"), (1, \"yy\"), (1, \"zz\"), D=3)\nmat = SS + 1/3 * SS^2\nH = trans_inv_operator(mat, 1:2, L)","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"The second input specifies the indices the operators act on.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"Because of the translational symmetry, we can simplify the problem by considering the symmetry. We construct a translational-symmetric basis by:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"B = TranslationalBasis(0, 8, base=3)","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"Here the first argument labels the momentum k = 0,...,L-1, the second argument is the length of the system. The function TranslationalBasis return a basis object containing 834 states. We can obtain the Hamiltonian in this sector by:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> H = trans_inv_operator(mat, 1:2, B)\nOperator of size (834, 834) with 8 terms.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"In addition, we can take into account the total Sz conservation, by constructing the basis","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"B = TranslationalBasis(x -> sum(x) == 8, 0, 8, base=3)","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"where the first argument is the selection function. The function (x -> sum(x) == 8) means we select those states whose total Sz equalls 0 (note that we use 0,1,2 to label the Sz=1,0,-1 states). This gives a further reduced Hamiltonian matrix:","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> H = trans_inv_operator(mat, 1:2, B)\nOperator of size (142, 142) with 8 terms.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"We can go on step further by considering the spatial reflection symmetry.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"B = TranslationParityBasis(x -> sum(x) == 8, 0, 1, L, base=3)","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"where the second argument is the momentum, the third argument is the parity p = ±1.","category":"page"},{"location":"expl/","page":"Examples","title":"Examples","text":"julia> H = trans_inv_operator(mat, 1:2, B)\nOperator of size (84, 84) with 8 terms.","category":"page"},{"location":"opts/#Operators","page":"Operator","title":"Operators","text":"","category":"section"},{"location":"opts/#Operator-Object","page":"Operator","title":"Operator Object","text":"","category":"section"},{"location":"opts/","page":"Operator","title":"Operator","text":"In EDKit.jl , a many-body operator is represented by the type Operator:","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"struct Operator{Tv<:Number, Tb<:AbstractBasis}\n    M::Vector{SparseMatrixCSC{Tv, Int}}\n    I::Vector{Vector{Int}}\n    B::Tb\nend","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"In this definition, M is the list of matrix representations of local operators, I is the list of indices of sites it acts on.","category":"page"},{"location":"opts/#Construction","page":"Operator","title":"Construction","text":"","category":"section"},{"location":"opts/","page":"Operator","title":"Operator","text":"To construct an Operator object, we need 3 inputs:","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"M <: AbstractVector{<:AbstractMatrix}\nI <: AbstractVector{<:AbstractVector{<:Integer}}\nB <: AbstractBasis","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"where M is the list of matrices representing the local operators, I is the list of vectors representing the sites it acts on. B is a basis object. If use TensorBasis, we can directly using the constructing method","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"operator(mats::AbstractVector{<:AbstractMatrix}, inds::AbstractVector{<:AbstractVector}, L::Integer)","category":"page"},{"location":"opts/#Convert-to-matrix","page":"Operator","title":"Convert to matrix","text":"","category":"section"},{"location":"opts/","page":"Operator","title":"Operator","text":"An Operator object is basically like a matrix, and it can be convert to dense matrix using the function","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"Array(opt::Operation)","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"It can also write to a given matrix with correct dimension using function","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"addto!(M::AbstractMatrix, opt::Operator)","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"Note that to get correct answer, M should de initialized as a zero matrix.","category":"page"},{"location":"opts/#Multiply-to-vector-or-matrix","page":"Operator","title":"Multiply to vector or matrix","text":"","category":"section"},{"location":"opts/","page":"Operator","title":"Operator","text":"We can directly using","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"O::Operator * M::AbstractVecOrMat","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"to do the multiplycation. Or, use the function","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"mul!(target::AbstractVecOrMat, opt::Operator, v::AbstractVecOrMat)","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"to modify target (similarly, target should be initialized as a zero vector/matrix).","category":"page"},{"location":"opts/#Compute-entaglement-entropy","page":"Operator","title":"Compute entaglement entropy","text":"","category":"section"},{"location":"opts/","page":"Operator","title":"Operator","text":"After obtaining Hamiltonian in a symmetry sector. We can calculate the entaglement entropy of an eigenvector v (assume the system size is 2L, and the entropy cut is at the middel of the chain) by","category":"page"},{"location":"opts/","page":"Operator","title":"Operator","text":"ent_S(v::AbstractVector, 1:L, b::AbstractBasis)","category":"page"},{"location":"#EDKit.jl","page":"Introduction","title":"EDKit.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Julia package for general many-body exact diagonalization calculation. The package provide a general Hamiltonian constructing routine for specific symmetry sectors. The functionalities can be extended with user-defined bases.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Run the following script in the Pkg REPL environment:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add EDKit","category":"page"}]
}
